import{_ as a,o,c as t,f as i,a as e,b as n,e as s}from"./app-A7gWX81E.js";const c="/blog.github.io/assets/image-He7dQFc1.png",l="/blog.github.io/assets/image-1-sxeBuUkB.png",d="/blog.github.io/assets/image-2-SXXkiW_F.png",r={},p=e("h2",{id:"http系列",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#http系列","aria-hidden":"true"},"#"),n(" http系列")],-1),h=s(`<h3 id="_1-http-报文结构是怎样的" tabindex="-1"><a class="header-anchor" href="#_1-http-报文结构是怎样的" aria-hidden="true">#</a> 1.HTTP 报文结构是怎样的？</h3><ul><li>TCP: 在传输的时候分为两个部分:TCP头和数据部分。</li><li>HTTP: header + body的结构(具体而言起始行 + 头部 + 空行 + 实体)</li></ul><blockquote><p>起始行:</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;!-- 请求报文 --&gt;
GET /home HTTP/1.1 (方法 + 路径 + http版本)
&lt;!-- 响应报文 --&gt;
HTTP/1.1 200 OK （http版+状态码+原因）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>头部: 字段名不区分大小写 字段名不允许出现空格，不可以出现下划线<code>_</code> 字段名后面必须紧接着<code>:</code></p></blockquote><blockquote><p>空行: 用来区分开头部和实体</p></blockquote><blockquote><p>实体: 也就是body部分。请求报文对应请求体, 响应报文对应响应体</p></blockquote><h3 id="_2-理解-http-的请求方法" tabindex="-1"><a class="header-anchor" href="#_2-理解-http-的请求方法" aria-hidden="true">#</a> 2.理解 HTTP 的请求方法</h3><ul><li>http/1.1规定了以下请求方法(注意，都是大写):</li><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><blockquote><p>GET 和 POST 有什么区别 从<code>缓存</code>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。 从<code>编码</code>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。 从<code>参数</code>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。 从<code>幂等性</code>的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的) 从<code>TCP</code>的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</p></blockquote><h3 id="_3-如何理解-uri" tabindex="-1"><a class="header-anchor" href="#_3-如何理解-uri" aria-hidden="true">#</a> 3.如何理解 URI</h3><blockquote><p>URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。 URI的结构 <img src="`+c+`" alt="alt text"><code>scheme</code> 表示协议名，比如http, https, file等等。后面必须和://连在一起 <code>user:passwd@</code> 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用 <code>host:port</code>表示主机名和端口 <code>path</code>表示请求路径，标记资源所在位置 <code>query</code>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用&amp;隔开 <code>fragment</code>表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置</p></blockquote><h3 id="_4-如何理解-http-状态码" tabindex="-1"><a class="header-anchor" href="#_4-如何理解-http-状态码" aria-hidden="true">#</a> 4.如何理解 HTTP 状态码</h3><blockquote><p><code>1xx</code>: 表示目前是协议处理的中间状态，还需要后续操作 <code>2xx</code>: 表示成功状态 <code>3xx</code>: 重定向状态，资源位置发生变动，需要重新请求 <code>4xx</code>: 请求报文有误 <code>5xx</code>: 服务器端发生错误</p></blockquote><ul><li>101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101</li><li>2xx 204 No Content含义与 200 相同，但响应头后没有 body 数据</li><li>206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段Content-Range。 -301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向</li><li>404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。</li><li>405 Method Not Allowed: 请求方法不被服务器端允许。</li><li>406 Not Acceptable: 资源无法满足客户端的条件。</li><li>408 Request Timeout: 服务器等待了太长时间。</li><li>409 Conflict: 多个请求发生了冲突。</li><li>413 Request Entity Too Large: 请求体的数据过大。</li><li>414 Request-URI Too Long: 请求行里的 URI 太大。</li><li>429 Too Many Request: 客户端发送的请求过多。</li><li>431 Request Header Fields Too Large请求头的字段内容太大</li></ul><h3 id="_5-http-的特点与缺点" tabindex="-1"><a class="header-anchor" href="#_5-http-的特点与缺点" aria-hidden="true">#</a> 5.HTTP 的特点与缺点</h3><p><strong>特点:</strong> 1.灵活可扩展 2.可靠传输 3.请求-应答 4.无状态 <strong>HTTP 缺点:</strong></p><ul><li>明文传输,即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式</li><li>队头阻塞问题 当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题</li></ul><h3 id="_6-对-accept-系列字段了解多少" tabindex="-1"><a class="header-anchor" href="#_6-对-accept-系列字段了解多少" aria-hidden="true">#</a> 6.对 Accept 系列字段了解多少</h3><ul><li>数据格式</li><li>压缩方式:(<code>gzip</code>: 当今最流行的压缩格式 | <code>eflate</code>: 另外一种著名的压缩格式 | <code>br</code>: 一种专门为 HTTP 发明的压缩算法)</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 发送端</span>
Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
<span class="token comment">// 接收端</span>
Accept<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-对于定长和不定长的数据-http-是怎么传输的" tabindex="-1"><a class="header-anchor" href="#_7-对于定长和不定长的数据-http-是怎么传输的" aria-hidden="true">#</a> 7: 对于定长和不定长的数据，HTTP 是怎么传输的</h3><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">//在 http 的响应体中会截去超出的长度</span>
Transfer<span class="token operator">-</span>Encoding<span class="token operator">:</span> chunked<span class="token punctuation">;</span> 
<span class="token comment">/* 表示分块传输数据；Content-Length 字段会被忽略;基于长连接持续推送动态内容 */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-http-如何处理大文件的传输" tabindex="-1"><a class="header-anchor" href="#_8-http-如何处理大文件的传输" aria-hidden="true">#</a> 8: HTTP 如何处理大文件的传输</h3><p>对于几百 M 甚至上 G 的大文件,HTTP采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 前提是服务器要支持范围请求;必须加上这样一个响应头</span>
Accept<span class="token operator">-</span>Ranges<span class="token operator">:</span> none
<span class="token comment">/* 0-499表示从开始到第 499 个字节。
500- 表示从第 500 字节到文件终点。
-100表示文件的最后100个字节。 */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-http-中如何处理表单数据的提交" tabindex="-1"><a class="header-anchor" href="#_9-http-中如何处理表单数据的提交" aria-hidden="true">#</a> 9: HTTP 中如何处理表单数据的提交</h3><p>http 中，有两种主要的表单提交的方式，体现在两种不同的<code>Content-Type</code>取值:</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li></ul><h3 id="_10-http1-1-如何解决-http-的队头阻塞问题" tabindex="-1"><a class="header-anchor" href="#_10-http1-1-如何解决-http-的队头阻塞问题" aria-hidden="true">#</a> 10: HTTP1.1 如何解决 HTTP 的队头阻塞问题</h3><p>HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。 解决方案： <code>并发连接</code>: 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。 <code>域名分片</code>: 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。 比如 content1.sanyuan.com 、content2.sanyuan.com。 这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h3 id="_11-对-cookie-了解多少" tabindex="-1"><a class="header-anchor" href="#_11-对-cookie-了解多少" aria-hidden="true">#</a> 11: 对 Cookie 了解多少</h3><p>HTTP 是一个无状态的协议,有时候需要保存一些状态，怎么办?HTTP 为此引入了 Cookie,服务端可以通过响应头中的<code>Set-Cookie</code>字段来对客户端写入<code>Cookie</code>.</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 请求头</span>
Cookie<span class="token operator">:</span> a<span class="token operator">=</span>xxx<span class="token punctuation">;</span>b<span class="token operator">=</span>xxx
<span class="token comment">// 响应头</span>
Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> a<span class="token operator">=</span>xxx
set<span class="token operator">-</span>Cookie<span class="token operator">:</span> b<span class="token operator">=</span>xxx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Cookie 属性</strong></p><ul><li>生存周期: Cookie 的有效期可以通过Expires和Max-Age两个属性来设置</li><li>作用域 Domain和path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。</li><li>安全相关 <ul><li>如果带上Secure，说明只能通过 HTTPS 传输 cookie.</li><li>如果 cookie 字段带上HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</li><li>CSRF 攻击的预防，也有SameSite属性(Strict、Lax和None): a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。 b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。 c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。</li></ul></li><li>缺点: 1.容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。 2.性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过Domain和Path指定作用域来解决。 3.安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获</li></ul><h3 id="_12-如何理解-http-代理" tabindex="-1"><a class="header-anchor" href="#_12-如何理解-http-代理" aria-hidden="true">#</a> 12: 如何理解 HTTP 代理</h3><ul><li><p>负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</p></li><li><p>保障安全。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</p></li><li><p>缓存代理。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。</p></li></ul><h3 id="_13-如何理解-http-缓存及缓存代理" tabindex="-1"><a class="header-anchor" href="#_13-如何理解-http-缓存及缓存代理" aria-hidden="true">#</a> 13: 如何理解 HTTP 缓存及缓存代理</h3><p>关于<code>强缓存</code>和<code>协商缓存</code>,首先通过 <code>Cache-Control </code>验证<code>强缓存</code>是否可用:</p><ul><li>如果<code>强缓存可用</code>，直接使用</li><li>否则进入<code>协商缓存</code>，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>这些<code>条件请求</code>字段检查资源是否更新</li><li>若资源更新，返回资源和200状态码</li><li>否则，返回304，告诉浏览器直接从缓存获取资源</li></ul><h3 id="_14-http-2-有哪些改进" tabindex="-1"><a class="header-anchor" href="#_14-http-2-有哪些改进" aria-hidden="true">#</a> 14.HTTP/2 有哪些改进</h3><p>由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p><ul><li><p>头部压缩 采用了对应的压缩算法——HPACK，对请求头进行压缩。 首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。 <img src="`+l+'" alt="alt text"></p></li><li><p>多路复用 <code>二进制分帧:</code>,原来Headers + Body的报文格式如今被拆分成了一个个二进制的帧，用Headers帧存放头部字段，Data帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。 通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念。</p></li></ul><p>-服务器推送 在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。 <img src="'+d+'" alt="alt text"></p>',45);function u(T,m){return o(),t("div",null,[p,i(" ![avatar](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/23/17104ea1fdee5669~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp) "),h])}const k=a(r,[["render",u],["__file","http.html.vue"]]);export{k as default};
